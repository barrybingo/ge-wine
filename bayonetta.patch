--- a/dlls/ntdll/file.c	
+++ a/dlls/ntdll/file.c	
@@ -865,7 +865,12 @@ NTSTATUS WINAPI NtReadFile(HANDLE hFile, HANDLE hEvent,
             status = STATUS_INVALID_PARAMETER;
             goto done;
         }
+        if (async_read) {
+            status = register_async_file_read( hFile, hEvent, apc, apc_user, io_status,
+                                               (char *)buffer+offset->QuadPart, total, length, FALSE );
 
+            goto err;
+        }
         if (offset && offset->QuadPart != FILE_USE_FILE_POINTER_POSITION)
         {
             /* async I/O doesn't make sense on regular files */
@@ -1175,6 +1180,38 @@ static NTSTATUS set_pending_write( HANDLE device )
     return status;
 }
 
+/* register an async I/O for a file write; helper for NtWriteFile */
+static NTSTATUS register_async_file_write( HANDLE handle, HANDLE event,
+                                          PIO_APC_ROUTINE apc, void *apc_user,
+                                          IO_STATUS_BLOCK *iosb, const void *buffer,
+                                          ULONG already, ULONG length )
+{
+    struct async_fileio_write *fileio;
+    NTSTATUS status;
+
+    fileio = (struct async_fileio_write *)alloc_fileio( sizeof(*fileio), FILE_AsyncWriteService, handle );
+    if (!fileio)
+    {
+        return STATUS_NO_MEMORY;
+    }
+    fileio->already = already;
+    fileio->count = length;
+    fileio->buffer = buffer;
+
+    SERVER_START_REQ( register_async )
+    {
+        req->type   = ASYNC_TYPE_WRITE;
+        req->count  = length;
+        req->async  = server_async( handle, &fileio->io, event, apc, apc_user, iosb );
+        status = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+
+    if (status != STATUS_PENDING) RtlFreeHeap( GetProcessHeap(), 0, fileio );
+    return status;
+}
+
+
 /******************************************************************************
  *  NtWriteFile					[NTDLL.@]
  *  ZwWriteFile					[NTDLL.@]
@@ -1275,6 +1312,13 @@ NTSTATUS WINAPI NtWriteFile(HANDLE hFile, HANDLE hEvent,
                 goto done;
             }
 
+            if (async_write)
+            {
+                status = register_async_file_write(hFile, hEvent, apc, apc_user, io_status,
+                                                   (char *)buffer+off, total, length);
+                goto err;
+            }
+
             /* async I/O doesn't make sense on regular files */
             while ((result = pwrite( unix_handle, buffer, length, off )) == -1)
             {
@@ -1336,28 +1380,9 @@ NTSTATUS WINAPI NtWriteFile(HANDLE hFile, HANDLE hEvent,
 
         if (async_write)
         {
-            struct async_fileio_write *fileio;
-
-            fileio = (struct async_fileio_write *)alloc_fileio( sizeof(*fileio), FILE_AsyncWriteService, hFile );
-            if (!fileio)
-            {
-                status = STATUS_NO_MEMORY;
-                goto err;
-            }
-            fileio->already = total;
-            fileio->count = length;
-            fileio->buffer = buffer;
-
-            SERVER_START_REQ( register_async )
-            {
-                req->type   = ASYNC_TYPE_WRITE;
-                req->count  = length;
-                req->async  = server_async( hFile, &fileio->io, hEvent, apc, apc_user, io_status );
-                status = wine_server_call( req );
-            }
-            SERVER_END_REQ;
 
-            if (status != STATUS_PENDING) RtlFreeHeap( GetProcessHeap(), 0, fileio );
+            status = register_async_file_write(hFile, hEvent, apc, apc_user, io_status,
+                                               buffer, total, length);
             goto err;
         }
         else  /* synchronous write, wait for the fd to become ready */
